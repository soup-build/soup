// code\tools\parse-modules\parser\ModuleParser.cpp generated by reflex 5.5.0 from code\tools\parse-modules\parser\ModuleParser.l

#define REFLEX_VERSION "5.5.0"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_fast
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_nodefault
#undef REFLEX_OPTION_noline
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_unicode

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           Soup::ParseModules
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_outfile             "code\\tools\\parse-modules\\parser\\ModuleParser.cpp"
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


module;

# include <iostream>
# include <chrono>
# include <optional>
# include <unordered_map>
# include <vector>

export module parse.modules:ModuleParser;
import reflex;
import :EarlyExitException;

enum class SimplifiedCppToken : int
{
    EndOfFile = 0,
    Identifier,
    NumberSign,
    LessThan,
    GreaterThan,
    Period,
    Colon,
    Semicolon,
    Module,
    Import,
    Export,
};



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOUP_BUILD
#include <reflex/matcher.h>
#endif

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOUP_BUILD
#include <reflex/abslexer.h>
#endif

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace Soup {
namespace ParseModules {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  // the lexer function defined by SECTION 2
  virtual int lex(void);
  // lexer functions accepting new input to scan
  int lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  int lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace Soup
} // namespace ParseModules

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace Soup {
namespace ParseModules {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace Soup
} // namespace ParseModules

int Soup::ParseModules::Lexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              lexer_error("scanner jammed");
              return int();
            }
            break;
          case 1: // rule code\tools\parse-modules\parser\ModuleParser.l:42: {whitespace} :
{ /* ignore whitespace */ }
            break;
          case 2: // rule code\tools\parse-modules\parser\ModuleParser.l:43: {preprocessor} :
{ /* ignore preprocessor statements */ }
            break;
          case 3: // rule code\tools\parse-modules\parser\ModuleParser.l:44: {comment} :
{ /* ignore comments */ }
            break;
          case 4: // rule code\tools\parse-modules\parser\ModuleParser.l:45: {multiline_comment} :
{ /* ignore comments */ }
            break;
          case 5: // rule code\tools\parse-modules\parser\ModuleParser.l:46: {newline} :
{ /* ignore newlines */ }
            break;
          case 6: // rule code\tools\parse-modules\parser\ModuleParser.l:47: "import" :
return (int)SimplifiedCppToken::Import;
            break;
          case 7: // rule code\tools\parse-modules\parser\ModuleParser.l:48: "export" :
return (int)SimplifiedCppToken::Export;
            break;
          case 8: // rule code\tools\parse-modules\parser\ModuleParser.l:49: "module" :
return (int)SimplifiedCppToken::Module;
            break;
          case 9: // rule code\tools\parse-modules\parser\ModuleParser.l:50: "#" :
return (int)SimplifiedCppToken::NumberSign;
            break;
          case 10: // rule code\tools\parse-modules\parser\ModuleParser.l:51: "<" :
return (int)SimplifiedCppToken::LessThan;
            break;
          case 11: // rule code\tools\parse-modules\parser\ModuleParser.l:52: ">" :
return (int)SimplifiedCppToken::GreaterThan;
            break;
          case 12: // rule code\tools\parse-modules\parser\ModuleParser.l:53: "." :
return (int)SimplifiedCppToken::Period;
            break;
          case 13: // rule code\tools\parse-modules\parser\ModuleParser.l:54: ":" :
return (int)SimplifiedCppToken::Colon;
            break;
          case 14: // rule code\tools\parse-modules\parser\ModuleParser.l:55: ";" :
return (int)SimplifiedCppToken::Semicolon;
            break;
          case 15: // rule code\tools\parse-modules\parser\ModuleParser.l:56: {identifier} :
return (int)SimplifiedCppToken::Identifier;
            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


namespace Soup::ParseModules
{

/// <summary>
/// Gradient decent Module parser
/// </summary>
export class ModuleParser : public Lexer
{
private:
    SimplifiedCppToken _currentToken;
    SimplifiedCppToken _nextToken;
    std::vector<std::string> _result;

public:
    ModuleParser(const reflex::Input& input) :
        Lexer(input),
        _currentToken(),
        _nextToken((SimplifiedCppToken)-1),
        _result()
    {
    }

    bool TryParse()
    {
        MoveNext();

        // Check if there is an optional global module declaration
        if (TryParseOptionalGlobalModuleFragment())
        {
            // TODO: Parse global module fragment

            // Must have a module declaration
            std::string moduleName;
            if (!TryParseModuleDeclaration(moduleName))
                throw std::runtime_error("TU with global module fragment must have a module declaration");

            _result.push_back("module " + moduleName);
        }
        else
        {
            // Check for optional module declarationn
            std::string moduleName;
            if (TryParseModuleDeclaration(moduleName))
            {
                _result.push_back("module " + moduleName);
            }
        }

        std::string importName;
        while (TryParseImportModule(importName))
        {
            _result.push_back("import " + importName);
        }

        return true;
    }

    std::vector<std::string> GetResult()
    {
      return std::move(_result);
    }

private:
    bool TryParseOptionalGlobalModuleFragment()
    {
        #ifdef SHOW_TOKENS
          std::cout << "TryParseOptionalGlobalModuleFragment" << std::endl;
        #endif

        // Verify first token is module
        if (_currentToken == SimplifiedCppToken::Module &&
          PeekNext() == SimplifiedCppToken::Semicolon)
        {
            // Move past the semicolon
            MoveNext();
            MoveNext();

            // There is a global module fragment
            return true;
        }

        return false;
    }

    bool TryParseModuleDeclaration(std::string& moduleName)
    {
        #ifdef SHOW_TOKENS
          std::cout << "TryParseModuleDeclaration" << std::endl;
        #endif

        // Check for optional first export token
        if (_currentToken == SimplifiedCppToken::Export)
        {
            MoveNext();
        }

        // Verify required module token
        if (_currentToken != SimplifiedCppToken::Module)
        {
            // Only return false here since there is not tokens that indicate a module declaration
            return false;
        }

        MoveNext();

        std::string result;
        if (!TryParseModuleName(result))
            throw std::runtime_error("Malformed module name in module declaration");

        // Check for optional partition
        std::string partitionName;
        if (TryParseModulePartition(partitionName))
        {
            result += partitionName;
        }

        // Verify semicolon after module name
        if (_currentToken != SimplifiedCppToken::Semicolon)
            throw std::runtime_error("Malformed module declaration");

        MoveNext();

        moduleName = std::move(result);
        return true;
    }

    bool TryParseModuleName(std::string& name)
    {
        #ifdef SHOW_TOKENS
          std::cout << "TryParseModuleName" << std::endl;
        #endif

        auto result = std::string();

        // Verify first token is an identifier
        if (_currentToken == SimplifiedCppToken::Identifier)
            result += str();
        else
            return false;

        // Check for optional period separators
        MoveNext();
        while (_currentToken == SimplifiedCppToken::Period)
        {
            result += str();

            // Verify required identifier
            MoveNext();
            if (_currentToken == SimplifiedCppToken::Identifier)
                result += str();
            else
                return false;

            MoveNext();
        }

        name = std::move(result);
        return true;
    }

    bool TryParseModulePartition(std::string& name)
    {
        #ifdef SHOW_TOKENS
          std::cout << "TryParseModulePartition" << std::endl;
        #endif

        // Verify first token is a colon
        if (_currentToken != SimplifiedCppToken::Colon)
            return false;

        MoveNext();
        auto moduleName = std::string();
        if (!TryParseModuleName(moduleName))
          return false;

        auto result = std::string(":");
        result += moduleName;
        name = std::move(result);
        return true;
    }

    bool TryParseHeaderName(std::string& name)
    {
        #ifdef SHOW_TOKENS
          std::cout << "TryParseHeaderName" << std::endl;
        #endif

        // TODO: Implement header imports
        name = "TODO";
        return false;
    }

    bool TryParseImportModule(std::string& name)
    {
        #ifdef SHOW_TOKENS
          std::cout << "TryParseImportModule" << std::endl;
        #endif

        // Check for optional first export and required import
        if (_currentToken == SimplifiedCppToken::Import)
        {
        }
        else if (_currentToken == SimplifiedCppToken::Export && PeekNext() == SimplifiedCppToken::Import)
        {
            // Has Export
            MoveNext();
        }
        else
        {
          return false;
        }

        MoveNext();

        auto result = std::string();
        if (TryParseModuleName(result))
        {
            name = std::move(result);
        }
        else if (TryParseModulePartition(result))
        {
            name = std::move(result);
        }
        else if (TryParseHeaderName(result))
        {
            name = std::move(result);
        }
        else
        {
            return false;
        }

        // Verify semicolon at end
        if (_currentToken != SimplifiedCppToken::Semicolon)
            return false;

        MoveNext();

        return true;
    }

    /// Lexer exceptions.
    virtual void lexer_error(const char* message = nullptr) override
    {
        // TODO: Add check for allowed errors when in a module declaration
        // For now, allow all errors
        std::stringstream stream_message;
        stream_message << (message != NULL ? message : "lexer error") << " at " << lineno() << ":" << columno();
        throw EarlyExitException(stream_message.str());
    }

    SimplifiedCppToken PeekNext()
    {
        if (_nextToken == (SimplifiedCppToken)-1)
        {
            _nextToken = (SimplifiedCppToken)lex();
        }

        return _nextToken;
    }

    SimplifiedCppToken MoveNext()
    {
        if (_nextToken != (SimplifiedCppToken)-1)
        {
            _currentToken = _nextToken;
            _nextToken = (SimplifiedCppToken)-1;
        }
        else
        {
            _currentToken = (SimplifiedCppToken)lex();
        }

        #ifdef SHOW_TOKENS
        switch (_currentToken)
        {
            case SimplifiedCppToken::EndOfFile:
                std::cout << "Token: " << "EndOfFile" << '\n';
                break;
            case SimplifiedCppToken::Module:
                std::cout << "Token: " << "Module" << '\n';
                break;
            case SimplifiedCppToken::Export:
                std::cout << "Token: " << "Export" << '\n';
                break;
            case SimplifiedCppToken::Import:
                std::cout << "Token: " << "Import" << '\n';
                break;
            case SimplifiedCppToken::Colon:
                std::cout << "Token: " << "Colon" << '\n';
                break;
            case SimplifiedCppToken::Semicolon:
                std::cout << "Token: " << "Semicolon" << '\n';
                break;
            case SimplifiedCppToken::Period:
                std::cout << "Token: " << "Period" << '\n';
                break;
            case SimplifiedCppToken::Identifier:
                std::cout << "Token: " << "Identifier" << '\n';
                break;
            default:
                std::cout << "Token: " << "UNKNOWN" << '\n';
                break;
        }
        #endif

        return _currentToken;
    }
};

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOUP_BUILD
#include <reflex/matcher.h>
#endif

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace Soup {
namespace ParseModules {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c = 0;
  m.FSM_INIT(c);

// S0:
  m.FSM_FIND();
  c = m.FSM_CHAR();
  if (c == 'm') goto S47;
  if (c == 'i') goto S33;
  if (c == 'e') goto S40;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if (c == '>') goto S56;
  if (c == '<') goto S54;
  if (c == ';') goto S62;
  if (c == ':') goto S60;
  if (c == '/') goto S26;
  if (c == '.') goto S58;
  if (c == '#') goto S22;
  if (c == ' ') goto S18;
  if (c == '\r') goto S29;
  if (c == '\n') goto S31;
  if (c == '\t') goto S18;
  return m.FSM_HALT(c);

S18:
  m.FSM_TAKE(1);
  c = m.FSM_CHAR();
  if (c == ' ') goto S18;
  if (c == '\t') goto S18;
  return m.FSM_HALT(c);

S22:
  m.FSM_TAKE(9);
  c = m.FSM_CHAR();
  if (c == '\r') goto S70;
  if (c == '\n') goto S72;
  if (0 <= c) goto S74;
  return m.FSM_HALT(c);

S26:
  c = m.FSM_CHAR();
  if (c == '/') goto S76;
  if (c == '*') goto S79;
  return m.FSM_HALT(c);

S29:
  c = m.FSM_CHAR();
  if (c == '\n') goto S31;
  return m.FSM_HALT(c);

S31:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S33:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'm') goto S90;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S40:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'x') goto S97;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S47:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'o') goto S104;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S54:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S56:
  m.FSM_TAKE(11);
  return m.FSM_HALT();

S58:
  m.FSM_TAKE(12);
  return m.FSM_HALT();

S60:
  m.FSM_TAKE(13);
  return m.FSM_HALT();

S62:
  m.FSM_TAKE(14);
  return m.FSM_HALT();

S64:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S70:
  c = m.FSM_CHAR();
  if (c == '\n') goto S72;
  if (0 <= c) goto S74;
  return m.FSM_HALT(c);

S72:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S74:
  c = m.FSM_CHAR();
  if (c == '\n') goto S72;
  if (0 <= c) goto S74;
  return m.FSM_HALT(c);

S76:
  c = m.FSM_CHAR();
  if (c == '\r') goto S111;
  if (c == '\n') goto S113;
  if (0 <= c) goto S115;
  return m.FSM_HALT(c);

S79:
  c = m.FSM_CHAR();
  if (c == 244) goto S131;
  if (241 <= c && c <= 243) goto S129;
  if (c == 240) goto S127;
  if (238 <= c && c <= 239) goto S125;
  if (c == 237) goto S123;
  if (225 <= c && c <= 236) goto S121;
  if (c == 224) goto S119;
  if (194 <= c && c <= 223) goto S117;
  if (128 <= c) return m.FSM_HALT(c);
  if (c == '*') goto S133;
  if (0 <= c && c <= 127) goto S79;
  return m.FSM_HALT(c);

S90:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'p') goto S145;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S97:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'p') goto S152;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S104:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'd') goto S159;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S111:
  c = m.FSM_CHAR();
  if (c == '\n') goto S113;
  if (0 <= c) goto S115;
  return m.FSM_HALT(c);

S113:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S115:
  c = m.FSM_CHAR();
  if (c == '\n') goto S113;
  if (0 <= c) goto S115;
  return m.FSM_HALT(c);

S117:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S119:
  c = m.FSM_CHAR();
  if (160 <= c && c <= 191) goto S166;
  return m.FSM_HALT(c);

S121:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S168;
  return m.FSM_HALT(c);

S123:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 159) goto S170;
  return m.FSM_HALT(c);

S125:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S172;
  return m.FSM_HALT(c);

S127:
  c = m.FSM_CHAR();
  if (144 <= c && c <= 191) goto S174;
  return m.FSM_HALT(c);

S129:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S176;
  return m.FSM_HALT(c);

S131:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 143) goto S178;
  return m.FSM_HALT(c);

S133:
  c = m.FSM_CHAR();
  if (c == 244) goto S205;
  if (241 <= c && c <= 243) goto S203;
  if (c == 240) goto S201;
  if (238 <= c && c <= 239) goto S199;
  if (c == 237) goto S197;
  if (225 <= c && c <= 236) goto S195;
  if (c == 224) goto S193;
  if (194 <= c && c <= 223) goto S191;
  if (128 <= c) return m.FSM_HALT(c);
  if (c == '/') goto S207;
  if (c == '*') goto S133;
  if (0 <= c && c <= 127) goto S180;
  return m.FSM_HALT(c);

S145:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'o') goto S209;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S152:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'o') goto S216;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S159:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'u') goto S223;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S166:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S168:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S170:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S172:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S174:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S230;
  return m.FSM_HALT(c);

S176:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S232;
  return m.FSM_HALT(c);

S178:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S234;
  return m.FSM_HALT(c);

S180:
  c = m.FSM_CHAR();
  if (c == 244) goto S250;
  if (241 <= c && c <= 243) goto S248;
  if (c == 240) goto S246;
  if (238 <= c && c <= 239) goto S244;
  if (c == 237) goto S242;
  if (225 <= c && c <= 236) goto S240;
  if (c == 224) goto S238;
  if (194 <= c && c <= 223) goto S236;
  if (128 <= c) return m.FSM_HALT(c);
  if (c == '*') goto S252;
  if (0 <= c && c <= 127) goto S180;
  return m.FSM_HALT(c);

S191:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S193:
  c = m.FSM_CHAR();
  if (160 <= c && c <= 191) goto S264;
  return m.FSM_HALT(c);

S195:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S266;
  return m.FSM_HALT(c);

S197:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 159) goto S268;
  return m.FSM_HALT(c);

S199:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S270;
  return m.FSM_HALT(c);

S201:
  c = m.FSM_CHAR();
  if (144 <= c && c <= 191) goto S272;
  return m.FSM_HALT(c);

S203:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S274;
  return m.FSM_HALT(c);

S205:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 143) goto S276;
  return m.FSM_HALT(c);

S207:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S209:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'r') goto S278;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S216:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'r') goto S285;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S223:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'l') goto S292;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S230:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S232:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S234:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S79;
  return m.FSM_HALT(c);

S236:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S238:
  c = m.FSM_CHAR();
  if (160 <= c && c <= 191) goto S299;
  return m.FSM_HALT(c);

S240:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S301;
  return m.FSM_HALT(c);

S242:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 159) goto S303;
  return m.FSM_HALT(c);

S244:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S305;
  return m.FSM_HALT(c);

S246:
  c = m.FSM_CHAR();
  if (144 <= c && c <= 191) goto S307;
  return m.FSM_HALT(c);

S248:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S309;
  return m.FSM_HALT(c);

S250:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 143) goto S311;
  return m.FSM_HALT(c);

S252:
  c = m.FSM_CHAR();
  if (c == 244) goto S205;
  if (241 <= c && c <= 243) goto S203;
  if (c == 240) goto S201;
  if (238 <= c && c <= 239) goto S199;
  if (c == 237) goto S197;
  if (225 <= c && c <= 236) goto S195;
  if (c == 224) goto S193;
  if (194 <= c && c <= 223) goto S191;
  if (128 <= c) return m.FSM_HALT(c);
  if (c == '/') goto S207;
  if (c == '*') goto S252;
  if (0 <= c && c <= 127) goto S180;
  return m.FSM_HALT(c);

S264:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S266:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S268:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S270:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S272:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S313;
  return m.FSM_HALT(c);

S274:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S315;
  return m.FSM_HALT(c);

S276:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S317;
  return m.FSM_HALT(c);

S278:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 't') goto S319;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S285:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 't') goto S325;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S292:
  m.FSM_TAKE(15);
  c = m.FSM_CHAR();
  if (c == 'e') goto S331;
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S299:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S301:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S303:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S305:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S307:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S337;
  return m.FSM_HALT(c);

S309:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S339;
  return m.FSM_HALT(c);

S311:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S341;
  return m.FSM_HALT(c);

S313:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S315:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S317:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S319:
  m.FSM_TAKE(6);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S325:
  m.FSM_TAKE(7);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S331:
  m.FSM_TAKE(8);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S64;
  if (c == '_') goto S64;
  if ('A' <= c && c <= 'Z') goto S64;
  if ('1' <= c && c <= '9') goto S64;
  return m.FSM_HALT(c);

S337:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S339:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);

S341:
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S180;
  return m.FSM_HALT(c);
}

} // namespace Soup

} // namespace ParseModules

