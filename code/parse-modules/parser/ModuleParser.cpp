// /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.cpp generated by reflex 5.2.1 from /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l

#define REFLEX_VERSION "5.2.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_fast
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_nodefault
#undef REFLEX_OPTION_noline
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_unicode

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           Soup::ModuleParser
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_outfile             "/home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.cpp"
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


module;

// #define SHOW_TOKENS

# include <iostream>
# include <chrono>
# include <optional>
# include <unordered_map>
# include <vector>

module Soup.ModuleParser;
import reflex;

enum class SimplifiedCppToken : int
{
    EndOfFile = 0,
    Newline,
    Colon,
    Semicolon,
    Comma,
    Module,
    Import,
    Export,
    Error,
};



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace Soup {
namespace ModuleParser {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int QUOTE = 1;
  // the lexer function defined by SECTION 2
  virtual int lex(void);
  // lexer functions accepting new input to scan
  int lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  int lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace Soup
} // namespace ModuleParser

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// BasicCharacter:
//      Tab Character, Letter, Number, Marks, Punctuation, Symbols, Separators
//      except "Quotation Mark", "Reverse Solidus"
//      (Everything except controls)

// KeyCharacter:
//      Letter, Numbers
// TODO: Remove extra symbols


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace Soup {
namespace ModuleParser {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace Soup
} // namespace ModuleParser
namespace Soup {
namespace ModuleParser {
extern void reflex_code_QUOTE(reflex::Matcher&);
} // namespace Soup
} // namespace ModuleParser

int Soup::ModuleParser::Lexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  static const reflex::Pattern PATTERN_QUOTE(reflex_code_QUOTE);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              lexer_error("scanner jammed");
              return int();
            }
            break;
          case 1: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:50: {whitespace} :
{ /* ignore whitespace */ }
            break;
          case 2: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:51: {preprocessor} :
{ /* ignore preprocessor statements */ }
            break;
          case 3: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:52: {comment} :
{ /* ignore comments */ }
            break;
          case 4: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:53: {newline} :
return (int)SimplifiedCppToken::Newline;
            break;
          case 5: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:54: "import" :
return (int)SimplifiedCppToken::Import;
            break;
          case 6: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:55: "export" :
return (int)SMLToken::Export;
            break;
          case 7: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:56: "module" :
return (int)SMLToken::Module;
            break;
          case 8: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:57: ":" :
return (int)SMLToken::Colon;
            break;
          case 9: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:58: ";" :
return (int)SMLToken::Semicolon;
            break;
          case 10: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:59: . :
return (int)SMLToken::Error;
            break;
        }
        break;
      case QUOTE:
        matcher().pattern(PATTERN_QUOTE);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              lexer_error("scanner jammed");
              return int();
            }
            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


namespace Soup::Core
{

/// <summary>
/// Gradient decent Module parser
/// </summary>
class ModuleParser : public ModuleParser::Lexer
{
private:
    SMLToken _currentToken;
    SMLTable _root;

public:
    ModuleParser(const reflex::Input& input) :
        Lexer(input),
        _currentToken(),
        _root()
    {
    }

    bool TryParse()
    {
        std::vector<std::string> imports;
        if (TryParseTranslationUnit(imports))
        {
            // Verify we are at the end of the content
            if (_currentToken != SMLToken::EndOfFile)
                return false;

            _root = SMLTable(std::move(table));
            return true;
        }
        else
        {
            return false;
        }
    }

private:
    bool TryParseTranslationUnit(std::vector<std::string>& imports)
    {
        // Verify match language name
        MoveNext();
        if (_currentToken != SMLToken::AlphaLiteral &&
            _currentToken != SMLToken::AlphaExt3Literal)
            return false;

        // Key token already matched
        auto languageName = str();

        // Verify the separator
        MoveNext();
        if (_currentToken != SMLToken::AtSign)
            return false;

        // Check version type
        SemanticVersion version;
        MoveNext();
        switch (_currentToken)
        {
            case SMLToken::Integer:
            {
                int64_t majorVersion = std::stoll(text());
                version = SemanticVersion(majorVersion);
                break;
            }
            case SMLToken::Decimal:
            {
                auto versionText = std::string_view(text());
                version = SemanticVersion::Parse(versionText);
                break;
            }
            default:
            {
                return false;
            }
        }

        // Verify we are at the end of the content
        MoveNext();
        if (_currentToken != SMLToken::CloseParenthesis)
            return false;

        languageReference = LanguageReference(
            std::move(languageName),
            version);

        return true;
    }

    SMLToken MoveNext()
    {
        _currentToken = (SMLToken)lex();

        #ifdef SHOW_TOKENS
            switch (_currentToken)
            {
                case SMLToken::EndOfFile:
                    std::cout << "Token: " << "EndOfFile" << '\n';
                    break;
                case SMLToken::Newline:
                    std::cout << "Token: " << "Newline" << '\n';
                    break;
                case SMLToken::KeyLiteral:
                    std::cout << "Token: " << "KeyLiteral" << '\n';
                    break;
                case SMLToken::Integer:
                    std::cout << "Token: " << "Integer" << '\n';
                    break;
                case SMLToken::Decimal:
                    std::cout << "Token: " << "Decimal" << '\n';
                    break;
                case SMLToken::Colon:
                    std::cout << "Token: " << "Colon" << '\n';
                    break;
                case SMLToken::Comma:
                    std::cout << "Token: " << "Comma" << '\n';
                    break;
                case SMLToken::OpenBracket:
                    std::cout << "Token: " << "OpenBracket" << '\n';
                    break;
                case SMLToken::CloseBracket:
                    std::cout << "Token: " << "CloseBracket" << '\n';
                    break;
                case SMLToken::OpenBrace:
                    std::cout << "Token: " << "OpenBrace" << '\n';
                    break;
                case SMLToken::CloseBrace:
                    std::cout << "Token: " << "CloseBrace" << '\n';
                    break;
                case SMLToken::StringLiteral:
                    std::cout << "Token: " << "StringLiteral" << '\n';
                    break;
                case SMLToken::True:
                    std::cout << "Token: " << "True" << '\n';
                    break;
                case SMLToken::False:
                    std::cout << "Token: " << "False" << '\n';
                    break;
                case SMLToken::Error:
                    std::cout << "Token: " << "Error" << '\n';
                    break;
                default:
                    std::cout << "Token: " << "UNKNOWN" << '\n';
                    break;
            }
        #endif

        return _currentToken;
    }
};

/*static*/ SMLDocument SMLDocument::Parse(std::istream& stream)
{
    auto input = reflex::Input(stream);
    auto parser = SMLParser(stream);
    if (parser.TryParse())
    {
        return parser.GetResult();
    }
    else
    {
        auto line = parser.lineno();
        auto column = parser.columno();
        auto text = parser.text();

        std::stringstream message;
        message << "Failed to parse at " << line << ":" << column << " " << text;
        throw std::runtime_error(message.str());
    }
}

/*static*/ SMLDocument SMLDocument::Parse(const char* data, size_t size)
{
    auto input = reflex::Input(data, size);
    auto parser = SMLParser(input);
    if (parser.TryParse())
    {
        return parser.GetResult();
    }
    else
    {
        auto line = parser.lineno();
        auto column = parser.columno();
        auto text = parser.text();

        std::stringstream message;
        message << "Failed to parse at " << line << ":" << column << " " << text;
        throw std::runtime_error(message.str());
    }
}

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace Soup {
namespace ModuleParser {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c = 0;
  m.FSM_INIT(c);

S0:
  m.FSM_FIND();
  c = m.FSM_CHAR();
  if (c == 'm') goto S40;
  if (c == 'i') goto S32;
  if (c == 'e') goto S36;
  if (c == ';') goto S47;
  if (c == ':') goto S44;
  if (c == '/') goto S22;
  if (c == '#') goto S17;
  if (c == ' ') goto S12;
  if (c == '\r') goto S26;
  if (c == '\n') goto S30;
  if (c == '\t') goto S12;
  if (0 <= c) goto S50;
  return m.FSM_HALT(c);

S12:
  m.FSM_TAKE(1);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  if (c == ' ') goto S53;
  if (c == '\t') goto S53;
  return m.FSM_HALT(c);

S17:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S61;
  if (c == '\r') goto S57;
  if (c == '\n') goto S59;
  if (0 <= c) goto S65;
  return m.FSM_HALT(c);

S22:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  if (c == '/') goto S67;
  return m.FSM_HALT(c);

S26:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  if (c == '\n') goto S30;
  return m.FSM_HALT(c);

S30:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S32:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  if (c == 'm') goto S70;
  return m.FSM_HALT(c);

S36:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  if (c == 'x') goto S72;
  return m.FSM_HALT(c);

S40:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  if (c == 'o') goto S74;
  return m.FSM_HALT(c);

S44:
  m.FSM_TAKE(8);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  return m.FSM_HALT(c);

S47:
  m.FSM_TAKE(9);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  return m.FSM_HALT(c);

S50:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S50;
  return m.FSM_HALT(c);

S53:
  m.FSM_TAKE(1);
  c = m.FSM_CHAR();
  if (c == ' ') goto S53;
  if (c == '\t') goto S53;
  return m.FSM_HALT(c);

S57:
  c = m.FSM_CHAR();
  if (c == '\n') goto S59;
  if (0 <= c) goto S65;
  return m.FSM_HALT(c);

S59:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S61:
  m.FSM_TAKE(10);
  c = m.FSM_CHAR();
  if (128 <= c && c <= 191) goto S61;
  if (c == '\n') goto S59;
  if (0 <= c) goto S65;
  return m.FSM_HALT(c);

S65:
  c = m.FSM_CHAR();
  if (c == '\n') goto S59;
  if (0 <= c) goto S65;
  return m.FSM_HALT(c);

S67:
  c = m.FSM_CHAR();
  if (c == '\r') goto S76;
  if (c == '\n') goto S78;
  if (0 <= c) goto S80;
  return m.FSM_HALT(c);

S70:
  c = m.FSM_CHAR();
  if (c == 'p') goto S82;
  return m.FSM_HALT(c);

S72:
  c = m.FSM_CHAR();
  if (c == 'p') goto S84;
  return m.FSM_HALT(c);

S74:
  c = m.FSM_CHAR();
  if (c == 'd') goto S86;
  return m.FSM_HALT(c);

S76:
  c = m.FSM_CHAR();
  if (c == '\n') goto S78;
  if (0 <= c) goto S80;
  return m.FSM_HALT(c);

S78:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S80:
  c = m.FSM_CHAR();
  if (c == '\n') goto S78;
  if (0 <= c) goto S80;
  return m.FSM_HALT(c);

S82:
  c = m.FSM_CHAR();
  if (c == 'o') goto S88;
  return m.FSM_HALT(c);

S84:
  c = m.FSM_CHAR();
  if (c == 'o') goto S90;
  return m.FSM_HALT(c);

S86:
  c = m.FSM_CHAR();
  if (c == 'u') goto S92;
  return m.FSM_HALT(c);

S88:
  c = m.FSM_CHAR();
  if (c == 'r') goto S94;
  return m.FSM_HALT(c);

S90:
  c = m.FSM_CHAR();
  if (c == 'r') goto S96;
  return m.FSM_HALT(c);

S92:
  c = m.FSM_CHAR();
  if (c == 'l') goto S98;
  return m.FSM_HALT(c);

S94:
  c = m.FSM_CHAR();
  if (c == 't') goto S100;
  return m.FSM_HALT(c);

S96:
  c = m.FSM_CHAR();
  if (c == 't') goto S102;
  return m.FSM_HALT(c);

S98:
  c = m.FSM_CHAR();
  if (c == 'e') goto S104;
  return m.FSM_HALT(c);

S100:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S102:
  m.FSM_TAKE(6);
  return m.FSM_HALT();

S104:
  m.FSM_TAKE(7);
  return m.FSM_HALT();
}

} // namespace Soup

} // namespace ModuleParser

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace Soup {
namespace ModuleParser {

void reflex_code_QUOTE(reflex::Matcher& m)
{
  int c = 0;
  m.FSM_INIT(c);

S0:
  m.FSM_FIND();
  m.FSM_TAKE(1);
  return m.FSM_HALT();
}

} // namespace Soup

} // namespace ModuleParser

