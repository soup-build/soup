// /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.cpp generated by reflex 5.2.1 from /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l

#define REFLEX_VERSION "5.2.1"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_fast
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_nodefault
#undef REFLEX_OPTION_noline
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_unicode

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           Soup::ParseModules
#define REFLEX_OPTION_nodefault           true
#define REFLEX_OPTION_noline              true
#define REFLEX_OPTION_outfile             "/home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.cpp"
#define REFLEX_OPTION_unicode             true

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


module;

# include <iostream>
# include <chrono>
# include <optional>
# include <unordered_map>
# include <vector>

export module Soup.ParseModules:ModuleParser;
import reflex;

enum class SimplifiedCppToken : int
{
    EndOfFile = 0,
    Identifier,
    Period,
    Colon,
    Semicolon,
    Module,
    Import,
    Export,
};



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOUP_BUILD
#include <reflex/matcher.h>
#endif

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOUP_BUILD
#include <reflex/abslexer.h>
#endif

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace Soup {
namespace ParseModules {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, std::cout by default
      std::ostream& os = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  // the lexer function defined by SECTION 2
  virtual int lex(void);
  // lexer functions accepting new input to scan
  int lex(const reflex::Input& input)
  {
    in(input);
    return lex();
  }
  int lex(const reflex::Input& input, std::ostream *os)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

} // namespace Soup
} // namespace ParseModules

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace Soup {
namespace ParseModules {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace Soup
} // namespace ParseModules

int Soup::ParseModules::Lexer::lex(void)
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              lexer_error("scanner jammed");
              return int();
            }
            break;
          case 1: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:37: {whitespace} :
{ /* ignore whitespace */ }
            break;
          case 2: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:38: {preprocessor} :
{ /* ignore preprocessor statements */ }
            break;
          case 3: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:39: {comment} :
{ /* ignore comments */ }
            break;
          case 4: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:40: {newline} :
{ /* ignore newlines */ }
            break;
          case 5: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:41: "import" :
return (int)SimplifiedCppToken::Import;
            break;
          case 6: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:42: "export" :
return (int)SimplifiedCppToken::Export;
            break;
          case 7: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:43: "module" :
return (int)SimplifiedCppToken::Module;
            break;
          case 8: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:44: "." :
return (int)SimplifiedCppToken::Period;
            break;
          case 9: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:45: ":" :
return (int)SimplifiedCppToken::Colon;
            break;
          case 10: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:46: ";" :
return (int)SimplifiedCppToken::Semicolon;
            break;
          case 11: // rule /home/mwasplund/source/repos/soup/scripts/linux/../../code/parse-modules/parser/ModuleParser.l:47: {identifier} :
return (int)SimplifiedCppToken::Identifier;
            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 3: user code                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


namespace Soup::ParseModules
{

/// <summary>
/// Gradient decent Module parser
/// </summary>
export class ModuleParser : public Lexer
{
private:
    SimplifiedCppToken _currentToken;

public:
    ModuleParser(const reflex::Input& input) :
        Lexer(input),
        _currentToken()
    {
    }

    bool TryParse()
    {
        std::vector<std::string> imports;
        if (TryParseTranslationUnit(imports))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

private:
    bool TryParseTranslationUnit(std::vector<std::string>& imports)
    {
        // Verify first token is module
        MoveNext();
        if (_currentToken != SimplifiedCppToken::Module)
            return false;

        // Verify semicolon
        MoveNext();
        if (_currentToken != SimplifiedCppToken::Semicolon)
            return false;

        // Verify first token is export
        MoveNext();
        if (_currentToken != SimplifiedCppToken::Export)
            return false;

        // Verify first token is module
        MoveNext();
        if (_currentToken != SimplifiedCppToken::Module)
            return false;

        std::string moduleName;
        if (!TryParseModuleName(moduleName))
            return false;

        // Verify semicolon after module name
        if (_currentToken != SimplifiedCppToken::Semicolon)
            return false;

        return true;
    }

    bool TryParseModuleName(std::string& name)
    {
        auto result = std::string();

        // Verify first token is an identifier
        MoveNext();
        if (_currentToken != SimplifiedCppToken::Identifier)
            return false;

        // Check for optional period separators
        MoveNext();
        while (_currentToken == SimplifiedCppToken::Period)
        {
            // Verify required identifier
            MoveNext();
            if (_currentToken != SimplifiedCppToken::Identifier)
                return false;

            MoveNext();
        }

        result = std::move(result);
        return true;
    }

    SimplifiedCppToken MoveNext()
    {
        _currentToken = (SimplifiedCppToken)lex();

        #ifdef SHOW_TOKENS
            switch (_currentToken)
            {
                case SimplifiedCppToken::EndOfFile:
                    std::cout << "Token: " << "EndOfFile" << '\n';
                    break;
                case SimplifiedCppToken::Module:
                    std::cout << "Token: " << "Module" << '\n';
                    break;
                case SimplifiedCppToken::Export:
                    std::cout << "Token: " << "Export" << '\n';
                    break;
                case SimplifiedCppToken::Import:
                    std::cout << "Token: " << "Import" << '\n';
                    break;
                case SimplifiedCppToken::Colon:
                    std::cout << "Token: " << "Colon" << '\n';
                    break;
                case SimplifiedCppToken::Semicolon:
                    std::cout << "Token: " << "Semicolon" << '\n';
                    break;
                case SimplifiedCppToken::Period:
                    std::cout << "Token: " << "Period" << '\n';
                    break;
                case SimplifiedCppToken::Identifier:
                    std::cout << "Token: " << "Identifier" << '\n';
                    break;
                default:
                    std::cout << "Token: " << "UNKNOWN" << '\n';
                    break;
            }
        #endif

        return _currentToken;
    }
};

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef SOUP_BUILD
#include <reflex/matcher.h>
#endif

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace Soup {
namespace ParseModules {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c = 0;
  m.FSM_INIT(c);

S0:
  m.FSM_FIND();
  c = m.FSM_CHAR();
  if (c == 'm') goto S41;
  if (c == 'i') goto S29;
  if (c == 'e') goto S35;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  if (c == ';') goto S51;
  if (c == ':') goto S49;
  if (c == '/') goto S23;
  if (c == '.') goto S47;
  if (c == '#') goto S20;
  if (c == ' ') goto S16;
  if (c == '\r') goto S25;
  if (c == '\n') goto S27;
  if (c == '\t') goto S16;
  return m.FSM_HALT(c);

S16:
  m.FSM_TAKE(1);
  c = m.FSM_CHAR();
  if (c == ' ') goto S16;
  if (c == '\t') goto S16;
  return m.FSM_HALT(c);

S20:
  c = m.FSM_CHAR();
  if (c == '\r') goto S58;
  if (c == '\n') goto S60;
  if (0 <= c) goto S62;
  return m.FSM_HALT(c);

S23:
  c = m.FSM_CHAR();
  if (c == '/') goto S64;
  return m.FSM_HALT(c);

S25:
  c = m.FSM_CHAR();
  if (c == '\n') goto S27;
  return m.FSM_HALT(c);

S27:
  m.FSM_TAKE(4);
  return m.FSM_HALT();

S29:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'm') goto S67;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S35:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'x') goto S73;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S41:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'o') goto S79;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S47:
  m.FSM_TAKE(8);
  return m.FSM_HALT();

S49:
  m.FSM_TAKE(9);
  return m.FSM_HALT();

S51:
  m.FSM_TAKE(10);
  return m.FSM_HALT();

S53:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S58:
  c = m.FSM_CHAR();
  if (c == '\n') goto S60;
  if (0 <= c) goto S62;
  return m.FSM_HALT(c);

S60:
  m.FSM_TAKE(2);
  return m.FSM_HALT();

S62:
  c = m.FSM_CHAR();
  if (c == '\n') goto S60;
  if (0 <= c) goto S62;
  return m.FSM_HALT(c);

S64:
  c = m.FSM_CHAR();
  if (c == '\r') goto S85;
  if (c == '\n') goto S87;
  if (0 <= c) goto S89;
  return m.FSM_HALT(c);

S67:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'p') goto S91;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S73:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'p') goto S97;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S79:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'd') goto S103;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S85:
  c = m.FSM_CHAR();
  if (c == '\n') goto S87;
  if (0 <= c) goto S89;
  return m.FSM_HALT(c);

S87:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S89:
  c = m.FSM_CHAR();
  if (c == '\n') goto S87;
  if (0 <= c) goto S89;
  return m.FSM_HALT(c);

S91:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'o') goto S109;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S97:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'o') goto S115;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S103:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'u') goto S121;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S109:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'r') goto S127;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S115:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'r') goto S133;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S121:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'l') goto S139;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S127:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 't') goto S145;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S133:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 't') goto S150;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S139:
  m.FSM_TAKE(11);
  c = m.FSM_CHAR();
  if (c == 'e') goto S155;
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S145:
  m.FSM_TAKE(5);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S150:
  m.FSM_TAKE(6);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);

S155:
  m.FSM_TAKE(7);
  c = m.FSM_CHAR();
  if ('a' <= c && c <= 'z') goto S53;
  if (c == '_') goto S53;
  if ('A' <= c && c <= 'Z') goto S53;
  return m.FSM_HALT(c);
}

} // namespace Soup

} // namespace ParseModules

